import logging
logging.getLogger('angr').setLevel('CRITICAL') #level: WARNING, INFO, NOTSET, DEBUG, ERROR, CRITICAL
import IPython
import angr, claripy
import enum

class Vulnerability_Analyser:

    def __init__(self, project: angr.Project):
        self.project = project
        stack_chk_fail_sym = self.project.loader.find_symbol("__stack_chk_fail")
        self.stack_chk_fail_addr = None
        if stack_chk_fail_sym is not None:
            self.stack_chk_fail_addr = self.project.loader.find_symbol("__stack_chk_fail").rebased_addr
        


    def check_unconstrained(self, state: angr.SimState):
        if state.solver.symbolic(state.regs.pc):
            return True
        return False

    def stack_smashing_checker(self, state: angr.SimState) -> bool:
        if self.stack_chk_fail_addr is None:
            return False
        if state.addr == self.stack_chk_fail_addr:
            return True
        return False

    def check(self, sm: angr.SimulationManager):
        if len(sm.unconstrained) > 0: 
            return (VULNERABILITIES.UNCONSTRAINED_PC, sm.unconstrained[0])
        if len(sm.errored) > 0: 
            if type(sm.errored[0].error) == angr.errors.SimSegfaultException:
                return (SIGNALS.SEGFAULT, sm.errored[0])
        for a in sm.active: 
            if self.stack_smashing_checker(a):
                return (VULNERABILITIES.STACK_SMASHING, a)
        for d in sm.deadended: 
            if self.stack_smashing_checker(d):
                return (VULNERABILITIES.STACK_SMASHING, d) 
        for e in sm.errored: 
            if self.stack_smashing_checker(e):
                return (VULNERABILITIES.STACK_SMASHING, d) 
        return None #FIXME in case of error this may need to be False

class VULNERABILITIES(enum.Enum):
    UNCONSTRAINED_PC = 1
    STACK_SMASHING = 2

class SIGNALS(enum.Enum):
    SEGFAULT = 1